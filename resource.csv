AlgorithmID,AlgorithmName,Category,ProblemSolved,TimeComplexity,SpaceComplexity,Paradigm,UsedDataStructures,Description
1
2,冒泡排序的应用,排序算法,数组排序的实际应用,可变,可变,比较排序,数组,冒泡排序在现实世界中的应用场景。
3,冒泡排序的理论理解,理论计算机科学,理解冒泡排序的原理,不适用,不适用,比较排序,数组,侧重于冒泡排序的理论基础和核心思想。
4,比较：冒泡排序 vs 选择排序,排序算法,比较冒泡排序和选择排序在数组排序方面的表现,可变,可变,比较排序,数组,详细比较冒泡排序和选择排序的性能和用例。
5,选择排序,排序算法,数组排序,O(n^2),O(1),比较排序,数组,通过重复找到未排序部分的最小元素并将其放在开头来排序数组。
6,选择排序的应用,排序算法,数组排序的实际应用,可变,可变,比较排序,数组,选择排序在现实世界中的应用场景。
7,选择排序的理论理解,理论计算机科学,理解选择排序的原理,不适用,不适用,比较排序,数组,侧重于选择排序的理论基础和核心思想。
8,比较：选择排序 vs 插入排序,排序算法,比较选择排序和插入排序在数组排序方面的表现,可变,可变,比较排序,数组,详细比较选择排序和插入排序的性能和用例。
9,插入排序,排序算法,数组排序,O(n^2),O(1),比较排序,数组,一次构建一个最终排序的数组。
10,插入排序的应用,排序算法,数组排序的实际应用,可变,可变,比较排序,数组,插入排序在现实世界中的应用场景。
11,插入排序的理论理解,理论计算机科学,理解插入排序的原理,不适用,不适用,比较排序,数组,侧重于插入排序的理论基础和核心思想。
12,比较：插入排序 vs 归并排序,排序算法,比较插入排序和归并排序在数组排序方面的表现,可变,可变,比较排序,数组,详细比较插入排序和归并排序的性能和用例。
13,归并排序,排序算法,数组排序,O(n log n),O(n),分治,数组,一种分治算法，将数组分成两半，分别排序，然后合并排序好的两半。
14,归并排序的应用,排序算法,数组排序的实际应用,可变,可变,分治,数组,归并排序在现实世界中的应用场景。
15,归并排序的理论理解,理论计算机科学,理解归并排序的原理,不适用,不适用,分治,数组,侧重于归并排序的理论基础和核心思想。
16,比较：归并排序 vs 快速排序,排序算法,比较归并排序和快速排序在数组排序方面的表现,可变,可变,分治,数组,详细比较归并排序和快速排序的性能和用例。
17,快速排序,排序算法,数组排序,O(n log n),O(log n) (平均), O(n) (最坏),分治,数组,一种高效的、原地、基于比较的排序算法。
18,快速排序 (最坏情况),排序算法,数组排序,O(n^2),O(log n) (平均), O(n) (最坏),分治,数组,一种高效的、原地、基于比较的排序算法。(最坏情况分析)
19,快速排序的应用,排序算法,数组排序的实际应用,可变,可变,分治,数组,快速排序在现实世界中的应用场景。
20,快速排序的理论理解,理论计算机科学,理解快速排序的原理,不适用,不适用,分治,数组,侧重于快速排序的理论基础和核心思想。
21,比较：快速排序 vs 堆排序,排序算法,比较快速排序和堆排序在数组排序方面的表现,可变,可变,分治,数组,详细比较快速排序和堆排序的性能和用例。
22,堆排序,排序算法,数组排序,O(n log n),O(1),比较排序,堆, 数组,一种基于二叉堆数据结构的比较排序技术。
23,堆排序的应用,排序算法,数组排序的实际应用,可变,可变,比较排序,堆, 数组,堆排序在现实世界中的应用场景。
24,堆排序的理论理解,理论计算机科学,理解堆排序的原理,不适用,不适用,比较排序,堆, 数组,侧重于堆排序的理论基础和核心思想。
25,比较：堆排序 vs 计数排序,排序算法,比较堆排序和计数排序在数组排序方面的表现,可变,可变,比较排序,堆, 数组,详细比较堆排序和计数排序的性能和用例。
26,计数排序,排序算法,在一定范围内排序整数,O(n+k),O(k),非比较排序,数组,通过计数每个不同元素的出现次数来排序元素。
27,计数排序的应用,排序算法,在一定范围内排序整数的实际应用,可变,可变,非比较排序,数组,计数排序在现实世界中的应用场景。
28,计数排序的理论理解,理论计算机科学,理解计数排序的原理,不适用,不适用,非比较排序,数组,侧重于计数排序的理论基础和核心思想。
29,比较：计数排序 vs 基数排序,排序算法,比较计数排序和基数排序在一定范围内排序整数方面的表现,可变,可变,非比较排序,数组,详细比较计数排序和基数排序的性能和用例。
30,基数排序,排序算法,排序固定位数的整数,O(nk),O(n+k),非比较排序,数组,通过处理单个数字来排序整数。
31,基数排序的应用,排序算法,排序固定位数的整数的实际应用,可变,可变,非比较排序,数组,基数排序在现实世界中的应用场景。
32,基数排序的理论理解,理论计算机科学,理解基数排序的原理,不适用,不适用,非比较排序,数组,侧重于基数排序的理论基础和核心思想。
33,比较：基数排序 vs 桶排序,排序算法,比较基数排序和桶排序在排序固定位数的整数方面的表现,可变,可变,非比较排序,数组,详细比较基数排序和桶排序的性能和用例。
34,桶排序,排序算法,在一定范围内排序数字,O(n+k),O(n+k),非比较排序,数组, 链表,将元素分配到多个桶中。
35,桶排序 (最坏情况),排序算法,在一定范围内排序数字,O(n^2),O(n+k),非比较排序,数组, 链表,将元素分配到多个桶中。(最坏情况分析)
36,桶排序的应用,排序算法,在一定范围内排序数字的实际应用,可变,可变,非比较排序,数组, 链表,桶排序在现实世界中的应用场景。
37,桶排序的理论理解,理论计算机科学,理解桶排序的原理,不适用,不适用,非比较排序,数组, 链表,侧重于桶排序的理论基础和核心思想。
38,比较：桶排序 vs 冒泡排序,排序算法,比较桶排序和冒泡排序在在一定范围内排序数字方面的表现,可变,可变,非比较排序,数组, 链表,详细比较桶排序和冒泡排序的性能和用例。
39,线性搜索,搜索算法,在数组中查找元素,O(n),O(1),暴力,数组,按顺序检查列表中的每个元素，直到找到匹配项。
40,线性搜索的应用,搜索算法,在数组中查找元素的实际应用,可变,可变,暴力,数组,线性搜索在现实世界中的应用场景。
41,线性搜索的理论理解,理论计算机科学,理解线性搜索的原理,不适用,不适用,暴力,数组,侧重于线性搜索的理论基础和核心思想。
42,比较：线性搜索 vs 二分搜索,搜索算法,比较线性搜索和二分搜索在数组中查找元素方面的表现,可变,可变,暴力,数组,详细比较线性搜索和二分搜索的性能和用例。
43,二分搜索,搜索算法,在排序数组中查找元素,O(log n),O(1),分治,数组,在排序数组中查找目标值的位置。
44,二分搜索的应用,搜索算法,在排序数组中查找元素的实际应用,可变,可变,分治,数组,二分搜索在现实世界中的应用场景。
45,二分搜索的理论理解,理论计算机科学,理解二分搜索的原理,不适用,不适用,分治,数组,侧重于二分搜索的理论基础和核心思想。
46,比较：二分搜索 vs 三分搜索,搜索算法,比较二分搜索和三分搜索在排序数组中查找元素方面的表现,可变,可变,分治,数组,详细比较二分搜索和三分搜索的性能和用例。
47,三分搜索,搜索算法,在排序数组中查找元素 (单峰函数),O(log n),O(1),分治,数组,与二分搜索类似，但将数组分成三部分。
48,三分搜索的应用,搜索算法,在排序数组中查找元素 (单峰函数) 的实际应用,可变,可变,分治,数组,三分搜索在现实世界中的应用场景。
49,三分搜索的理论理解,理论计算机科学,理解三分搜索的原理,不适用,不适用,分治,数组,侧重于三分搜索的理论基础和核心思想。
50,比较：三分搜索 vs 线性搜索,搜索算法,比较三分搜索和线性搜索在在排序数组中查找元素 (单峰函数) 方面的表现,可变,可变,分治,数组,详细比较三分搜索和线性搜索的性能和用例。
51,BFS,图遍历,遍历图/树,O(V+E),O(V),图遍历,队列, 图,探索当前深度级别的所有邻居节点，然后进入下一个深度级别。
52,BFS的应用,图遍历,遍历图/树的实际应用,可变,可变,图遍历,队列, 图,BFS在现实世界中的应用场景。
53,BFS的理论理解,理论计算机科学,理解BFS的原理,不适用,不适用,图遍历,队列, 图,侧重于BFS的理论基础和核心思想。
54,比较：BFS vs DFS,图遍历,比较BFS和DFS在遍历图/树方面的表现,可变,可变,图遍历,队列, 图,详细比较BFS和DFS的性能和用例。
55,DFS,图遍历,遍历图/树,O(V+E),O(V),图遍历,栈, 图,在回溯之前，尽可能地沿每个分支探索。
56,DFS的应用,图遍历,遍历图/树的实际应用,可变,可变,图遍历,栈, 图,DFS在现实世界中的应用场景。
57,DFS的理论理解,理论计算机科学,理解DFS的原理,不适用,不适用,图遍历,栈, 图,侧重于DFS的理论基础和核心思想。
58,比较：DFS vs Dijkstra算法,图遍历,比较DFS和Dijkstra算法在遍历图/树方面的表现,可变,可变,图遍历,栈, 图,详细比较DFS和Dijkstra算法的性能和用例。
59,Dijkstra算法,图算法,加权图中的最短路径 (非负权重),O((V+E) log V) 或 O(E log V),O(V),贪心,优先队列, 图,找到图中节点之间的最短路径。
60,Dijkstra算法的应用,图算法,加权图中最短路径 (非负权重) 的实际应用,可变,可变,贪心,优先队列, 图,Dijkstra算法在现实世界中的应用场景。
61,Dijkstra算法的理论理解,理论计算机科学,理解Dijkstra算法的原理,不适用,不适用,贪心,优先队列, 图,侧重于Dijkstra算法的理论基础和核心思想。
62,比较：Dijkstra算法 vs Prim算法,图算法,比较Dijkstra算法和Prim算法在加权图中最短路径 (非负权重) 方面的表现,可变,可变,贪心,优先队列, 图,详细比较Dijkstra算法和Prim算法的性能和用例。
63,Prim算法,图算法,最小生成树,O(E log V) 或 O(V^2),O(V),贪心,优先队列, 图,找到加权无向图的最小生成树。
64,Prim算法的应用,图算法,最小生成树的实际应用,可变,可变,贪心,优先队列, 图,Prim算法在现实世界中的应用场景。
65,Prim算法的理论理解,理论计算机科学,理解Prim算法的原理,不适用,不适用,贪心,优先队列, 图,侧重于Prim算法的理论基础和核心思想。
66,比较：Prim算法 vs Kruskal算法,图算法,比较Prim算法和Kruskal算法在最小生成树方面的表现,可变,可变,贪心,优先队列, 图,详细比较Prim算法和Kruskal算法的性能和用例。
67,Kruskal算法,图算法,最小生成树,O(E log E) 或 O(E log V),O(V+E),贪心,不相交集, 图,找到连通无向图的最小生成树。
68,Kruskal算法的应用,图算法,最小生成树的实际应用,可变,可变,贪心,不相交集, 图,Kruskal算法在现实世界中的应用场景。
69,Kruskal算法的理论理解,理论计算机科学,理解Kruskal算法的原理,不适用,不适用,贪心,不相交集, 图,侧重于Kruskal算法的理论基础和核心思想。
70,比较：Kruskal算法 vs Bellman-Ford算法,图算法,比较Kruskal算法和Bellman-Ford算法在最小生成树方面的表现,可变,可变,贪心,不相交集, 图,详细比较Kruskal算法和Bellman-Ford算法的性能和用例。
71,Bellman-Ford算法,图算法,加权图中的最短路径 (带负权重),O(VE),O(V),动态规划,图,计算加权有向图中从单个源顶点到所有其他顶点的最短路径。
72,Bellman-Ford算法的应用,图算法,加权图中最短路径 (带负权重) 的实际应用,可变,可变,动态规划,图,Bellman-Ford算法在现实世界中的应用场景。
73,Bellman-Ford算法的理论理解,理论计算机科学,理解Bellman-Ford算法的原理,不适用,不适用,动态规划,图,侧重于Bellman-Ford算法的理论基础和核心思想。
74,比较：Bellman-Ford算法 vs Floyd-Warshall算法,图算法,比较Bellman-Ford算法和Floyd-Warshall算法在加权图中最短路径 (带负权重) 方面的表现,可变,可变,动态规划,图,详细比较Bellman-Ford算法和Floyd-Warshall算法的性能和用例。
75,Floyd-Warshall算法,图算法,所有对最短路径,O(V^3),O(V^2),动态规划,图, 矩阵,找到加权图中具有正或负边权重的最短路径。
76,Floyd-Warshall算法的应用,图算法,所有对最短路径的实际应用,可变,可变,动态规划,图, 矩阵,Floyd-Warshall算法在现实世界中的应用场景。
77,Floyd-Warshall算法的理论理解,理论计算机科学,理解Floyd-Warshall算法的原理,不适用,不适用,动态规划,图, 矩阵,侧重于Floyd-Warshall算法的理论基础和核心思想。
78,比较：Floyd-Warshall算法 vs 拓扑排序,图算法,比较Floyd-Warshall算法和拓扑排序在所有对最短路径方面的表现,可变,可变,动态规划,图, 矩阵,详细比较Floyd-Warshall算法和拓扑排序的性能和用例。
79,拓扑排序,图算法,DAG顶点的线性排序,O(V+E),O(V),图遍历,图, 栈/队列,顶点的线性排序，使得对于每个有向边uv，顶点u在v之前。
80,拓扑排序的应用,图算法,DAG顶点线性排序的实际应用,可变,可变,图遍历,图, 栈/队列,拓扑排序在现实世界中的应用场景。
81,拓扑排序的理论理解,理论计算机科学,理解拓扑排序的原理,不适用,不适用,图遍历,图, 栈/队列,侧重于拓扑排序的理论基础和核心思想。
82,比较：拓扑排序 vs 斐波那契数列 (动态规划),图算法,比较拓扑排序和斐波那契数列 (动态规划) 在DAG顶点线性排序方面的表现,可变,可变,图遍历,图, 栈/队列,详细比较拓扑排序和斐波那契数列 (动态规划) 的性能和用例。
83,斐波那契数列 (动态规划),动态规划,计算斐波那契数,O(n),O(n) 或 O(1),动态规划,数组,使用记忆化或表格法计算斐波那契数。
84,斐波那契数列 (动态规划) 的应用,动态规划,计算斐波那契数的实际应用,可变,可变,动态规划,数组,斐波那契数列 (动态规划) 在现实世界中的应用场景。
85,斐波那契数列 (动态规划) 的理论理解,理论计算机科学,理解斐波那契数列 (动态规划) 的原理,不适用,不适用,动态规划,数组,侧重于斐波那契数列 (动态规划) 的理论基础和核心思想。
86,比较：斐波那契数列 (动态规划) vs 最长公共子序列,动态规划,比较斐波那契数列 (动态规划) 和最长公共子序列在计算斐波那契数方面的表现,可变,可变,动态规划,数组,详细比较斐波那契数列 (动态规划) 和最长公共子序列的性能和用例。
87,最长公共子序列,动态规划,查找两个序列的LCS,O(mn),O(mn),动态规划,矩阵,找到两个序列共有的最长子序列。
88,最长公共子序列的应用,动态规划,查找两个序列LCS的实际应用,可变,可变,动态规划,矩阵,最长公共子序列在现实世界中的应用场景。
89,最长公共子序列的理论理解,理论计算机科学,理解最长公共子序列的原理,不适用,不适用,动态规划,矩阵,侧重于最长公共子序列的理论基础和核心思想。
90,比较：最长公共子序列 vs 背包问题 (0/1),动态规划,比较最长公共子序列和背包问题 (0/1) 在查找两个序列LCS方面的表现,可变,可变,动态规划,矩阵,详细比较最长公共子序列和背包问题 (0/1) 的性能和用例。
91,背包问题 (0/1),动态规划,背包中的最大化价值,O(nW),O(nW),动态规划,矩阵,给定重量和价值，找到物品以在容量内最大化价值。
92,背包问题 (0/1) 的应用,动态规划,背包中最大化价值的实际应用,可变,可变,动态规划,矩阵,背包问题 (0/1) 在现实世界中的应用场景。
93,背包问题 (0/1) 的理论理解,理论计算机科学,理解背包问题 (0/1) 的原理,不适用,不适用,动态规划,矩阵,侧重于背包问题 (0/1) 的理论基础和核心思想。
94,比较：背包问题 (0/1) vs 矩阵链乘法,动态规划,比较背包问题 (0/1) 和矩阵链乘法在背包中最大化价值方面的表现,可变,可变,动态规划,矩阵,详细比较背包问题 (0/1) 和矩阵链乘法的性能和用例。
95,矩阵链乘法,动态规划,矩阵乘法的最优括号化,O(n^3),O(n^2),动态规划,矩阵,找到给定矩阵序列相乘的最有效方法。
96,矩阵链乘法的应用,动态规划,矩阵乘法最优括号化的实际应用,可变,可变,动态规划,矩阵,矩阵链乘法在现实世界中的应用场景。
97,矩阵链乘法的理论理解,理论计算机科学,理解矩阵链乘法的原理,不适用,不适用,动态规划,矩阵,侧重于矩阵链乘法的理论基础和核心思想。
98,比较：矩阵链乘法 vs 活动选择,动态规划,比较矩阵链乘法和活动选择在矩阵乘法最优括号化方面的表现,可变,可变,动态规划,矩阵,详细比较矩阵链乘法和活动选择的性能和用例。
99,活动选择,贪心算法,最大化不重叠活动的数量,O(n log n),O(1),贪心,数组,选择一个人可以执行的最大数量的活动。
100,活动选择的应用,贪心算法,最大化不重叠活动数量的实际应用,可变,可变,贪心,数组,活动选择在现实世界中的应用场景。
101,活动选择的理论理解,理论计算机科学,理解活动选择的原理,不适用,不适用,贪心,数组,侧重于活动选择的理论基础和核心思想。
102,比较：活动选择 vs 分数背包,贪心算法,比较活动选择和分数背包在最大化不重叠活动数量方面的表现,可变,可变,贪心,数组,详细比较活动选择和分数背包的性能和用例。
103,分数背包,贪心算法,背包中的最大化价值 (物品可以是分数的),O(n log n),O(1),贪心,数组,解决背包问题，其中物品可以按分数取。
104,分数背包的应用,贪心算法,背包中最大化价值 (物品可以是分数的) 的实际应用,可变,可变,贪心,数组,分数背包在现实世界中的应用场景。
105,分数背包的理论理解,理论计算机科学,理解分数背包的原理,不适用,不适用,贪心,数组,侧重于分数背包的理论基础和核心思想。
106,比较：分数背包 vs Huffman编码,贪心算法,比较分数背包和Huffman编码在背包中最大化价值 (物品可以是分数的) 方面的表现,可变,可变,贪心,数组,详细比较分数背包和Huffman编码的性能和用例。
107,Huffman编码,贪心算法,无损数据压缩,O(n log n),O(n),贪心,优先队列, 树,一种使用变长编码的数据压缩算法。
108,Huffman编码的应用,贪心算法,无损数据压缩的实际应用,可变,可变,贪心,优先队列, 树,Huffman编码在现实世界中的应用场景。
109,Huffman编码的理论理解,理论计算机科学,理解Huffman编码的原理,不适用,不适用,贪心,优先队列, 树,侧重于Huffman编码的理论基础和核心思想。
110,比较：Huffman编码 vs 汉诺塔,贪心算法,比较Huffman编码和汉诺塔在无损数据压缩方面的表现,可变,可变,贪心,优先队列, 树,详细比较Huffman编码和汉诺塔的性能和用例。
111,汉诺塔,递归,解决汉诺塔谜题,O(2^n),O(n),分治, 递归,栈,一个数学游戏或谜题，目标是在塔之间移动圆盘。
112,汉诺塔的应用,递归,解决汉诺塔谜题的实际应用,可变,可变,分治, 递归,栈,汉诺塔在现实世界中的应用场景。
113,汉诺塔的理论理解,理论计算机科学,理解汉诺塔的原理,不适用,不适用,分治, 递归,栈,侧重于汉诺塔的理论基础和核心思想。
114,比较：汉诺塔 vs N皇后问题,递归,比较汉诺塔和N皇后问题在解决汉诺塔谜题方面的表现,可变,可变,分治, 递归,栈,详细比较汉诺塔和N皇后问题的性能和用例。
115,N皇后问题,回溯,在N×N棋盘上放置N个不互相攻击的皇后,O(n!),O(n^2),回溯,数组, 矩阵,在N×N棋盘上放置N个国际象棋皇后，使它们互不威胁。
116,N皇后问题的应用,回溯,在N×N棋盘上放置N个不互相攻击的皇后的实际应用,可变,可变,回溯,数组, 矩阵,N皇后问题在现实世界中的应用场景。
117,N皇后问题的理论理解,理论计算机科学,理解N皇后问题的原理,不适用,不适用,回溯,数组, 矩阵,侧重于N皇后问题的理论基础和核心思想。
118,比较：N皇后问题 vs 数独求解器,回溯,比较N皇后问题和数独求解器在N×N棋盘上放置N个不互相攻击的皇后方面的表现,可变,可变,回溯,数组, 矩阵,详细比较N皇后问题和数独求解器的性能和用例。
119,数独求解器,回溯,解决数独谜题,可变,O(1),回溯,矩阵,找到数独谜题的解决方案。
120,数独求解器的应用,回溯,解决数独谜题的实际应用,可变,可变,回溯,矩阵,数独求解器在现实世界中的应用场景。
121,数独求解器的理论理解,理论计算机科学,理解数独求解器的原理,不适用,不适用,回溯,矩阵,侧重于数独求解器的理论基础和核心思想。
122,比较：数独求解器 vs 排列,回溯,比较数独求解器和排列在解决数独谜题方面的表现,可变,可变,回溯,矩阵,详细比较数独求解器和排列的性能和用例。
123,排列,回溯,生成集合的所有排列,O(n*n!),O(n),回溯,数组,生成给定集合的所有可能排序。
124,排列的应用,回溯,生成集合的所有排列的实际应用,可变,可变,回溯,数组,排列在现实世界中的应用场景。
125,排列的理论理解,理论计算机科学,理解排列的原理,不适用,不适用,回溯,数组,侧重于排列的理论基础和核心思想。
126,比较：排列 vs 组合,回溯,比较排列和组合在生成集合的所有排列方面的表现,可变,可变,回溯,数组,详细比较排列和组合的性能和用例。
127,组合,回溯,生成集合的所有组合,O(n choose k * k),O(k),回溯,数组,从集合中生成给定大小的所有可能子集。
128,组合的应用,回溯,生成集合的所有组合的实际应用,可变,可变,回溯,数组,组合在现实世界中的应用场景。
129,组合的理论理解,理论计算机科学,理解组合的原理,不适用,不适用,回溯,数组,侧重于组合的理论基础和核心思想。
130,比较：组合 vs KMP算法,回溯,比较组合和KMP算法在生成集合的所有组合方面的表现,可变,可变,回溯,数组,详细比较组合和KMP算法的性能和用例。
131,KMP算法,字符串匹配,字符串中的模式匹配,O(m+n),O(m),字符串匹配,数组, 字符串,一种高效的字符串搜索算法，避免重新检查已匹配的字符。
132,KMP算法的应用,字符串匹配,字符串中模式匹配的实际应用,可变,可变,字符串匹配,数组, 字符串,KMP算法在现实世界中的应用场景。
133,KMP算法的理论理解,理论计算机科学,理解KMP算法的原理,不适用,不适用,字符串匹配,数组, 字符串,侧重于KMP算法的理论基础和核心思想。
134,比较：KMP算法 vs Rabin-Karp算法,字符串匹配,比较KMP算法和Rabin-Karp算法在字符串中模式匹配方面的表现,可变,可变,字符串匹配,数组, 字符串,详细比较KMP算法和Rabin-Karp算法的性能和用例。
135,Rabin-Karp算法,字符串匹配,字符串中的模式匹配,O(m+n),O(1),字符串匹配,字符串,使用哈希查找文本中一组模式字符串中的任意一个。
136,Rabin-Karp算法 (最坏情况),字符串匹配,字符串中的模式匹配,O(mn),O(1),字符串匹配,字符串,使用哈希查找文本中一组模式字符串中的任意一个。(最坏情况分析)
137,Rabin-Karp算法的应用,字符串匹配,字符串中模式匹配的实际应用,可变,可变,字符串匹配,字符串,Rabin-Karp算法在现实世界中的应用场景。
138,Rabin-Karp算法的理论理解,理论计算机科学,理解Rabin-Karp算法的原理,不适用,不适用,字符串匹配,字符串,侧重于Rabin-Karp算法的理论基础和核心思想。
139,比较：Rabin-Karp算法 vs Boyer-Moore算法,字符串匹配,比较Rabin-Karp算法和Boyer-Moore算法在字符串中模式匹配方面的表现,可变,可变,字符串匹配,字符串,详细比较Rabin-Karp算法和Boyer-Moore算法的性能和用例。
140,Boyer-Moore算法,字符串匹配,字符串中的模式匹配,O(n/m),O(alphabet_size),字符串匹配,字符串,一种高效的字符串搜索算法，跳过文本的某些部分。
141,Boyer-Moore算法 (最坏情况),字符串匹配,字符串中的模式匹配,O(mn),O(alphabet_size),字符串匹配,字符串,一种高效的字符串搜索算法，跳过文本的某些部分。(最坏情况分析)
142,Boyer-Moore算法的应用,字符串匹配,字符串中模式匹配的实际应用,可变,可变,字符串匹配,字符串,Boyer-Moore算法在现实世界中的应用场景。
143,Boyer-Moore算法的理论理解,理论计算机科学,理解Boyer-Moore算法的原理,不适用,不适用,字符串匹配,字符串,侧重于Boyer-Moore算法的理论基础和核心思想。
144,比较：Boyer-Moore算法 vs 哈希表操作,字符串匹配,比较Boyer-Moore算法和哈希表操作在字符串中模式匹配方面的表现,可变,可变,字符串匹配,字符串,详细比较Boyer-Moore算法和哈希表操作的性能和用例。
145,哈希表操作,数据结构,存储和检索数据,O(1),O(n),哈希,哈希表, 数组, 链表,哈希表的基本操作 (插入、删除、查找)。
146,哈希表操作 (最坏情况),数据结构,存储和检索数据,O(n),O(n),哈希,哈希表, 数组, 链表,哈希表的基本操作 (插入、删除、查找)。(最坏情况分析)
147,哈希表操作的应用,数据结构,存储和检索数据的实际应用,可变,可变,哈希,哈希表, 数组, 链表,哈希表操作在现实世界中的应用场景。
148,哈希表操作的理论理解,理论计算机科学,理解哈希表操作的原理,不适用,不适用,哈希,哈希表, 数组, 链表,侧重于哈希表操作的理论基础和核心思想。
149,比较：哈希表操作 vs 树遍历 (中序),数据结构,比较哈希表操作和树遍历 (中序) 在存储和检索数据方面的表现,可变,可变,哈希,哈希表, 数组, 链表,详细比较哈希表操作和树遍历 (中序) 的性能和用例。
150,树遍历 (中序),树遍历,访问二叉树中的节点,O(n),O(h),树遍历,树,按顺序访问节点：左、根、右。
151,树遍历 (中序) 的应用,树遍历,访问二叉树中节点的实际应用,可变,可变,树遍历,树,树遍历 (中序) 在现实世界中的应用场景。
152,树遍历 (中序) 的理论理解,理论计算机科学,理解树遍历 (中序) 的原理,不适用,不适用,树遍历,树,侧重于树遍历 (中序) 的理论基础和核心思想。
153,比较：树遍历 (中序) vs 树遍历 (前序),树遍历,比较树遍历 (中序) 和树遍历 (前序) 在访问二叉树中节点方面的表现,可变,可变,树遍历,树,详细比较树遍历 (中序) 和树遍历 (前序) 的性能和用例。
154,树遍历 (前序),树遍历,访问二叉树中的节点,O(n),O(h),树遍历,树,按顺序访问节点：根、左、右。
155,树遍历 (前序) 的应用,树遍历,访问二叉树中节点的实际应用,可变,可变,树遍历,树,树遍历 (前序) 在现实世界中的应用场景。
156,树遍历 (前序) 的理论理解,理论计算机科学,理解树遍历 (前序) 的原理,不适用,不适用,树遍历,树,侧重于树遍历 (前序) 的理论基础和核心思想。
157,比较：树遍历 (前序) vs 树遍历 (后序),树遍历,比较树遍历 (前序) 和树遍历 (后序) 在访问二叉树中节点方面的表现,可变,可变,树遍历,树,详细比较树遍历 (前序) 和树遍历 (后序) 的性能和用例。
158,树遍历 (后序),树遍历,访问二叉树中的节点,O(n),O(h),树遍历,树,按顺序访问节点：左、右、根。
159,树遍历 (后序) 的应用,树遍历,访问二叉树中节点的实际应用,可变,可变,树遍历,树,树遍历 (后序) 在现实世界中的应用场景。
160,树遍历 (后序) 的理论理解,理论计算机科学,理解树遍历 (后序) 的原理,不适用,不适用,树遍历,树,侧重于树遍历 (后序) 的理论基础和核心思想。
161,比较：树遍历 (后序) vs BST操作 (搜索),树遍历,比较树遍历 (后序) 和BST操作 (搜索) 在访问二叉树中节点方面的表现,可变,可变,树遍历,树,详细比较树遍历 (后序) 和BST操作 (搜索) 的性能和用例。
162,BST操作 (搜索),树算法,在二叉搜索树中搜索,O(h),O(h),树算法,二叉搜索树,在BST中查找具有特定值的节点。
163,BST操作 (搜索) (最坏情况),树算法,在二叉搜索树中搜索,O(n),O(h),树算法,二叉搜索树,在BST中查找具有特定值的节点。(最坏情况分析)
164,BST操作 (搜索) 的应用,树算法,在二叉搜索树中搜索的实际应用,可变,可变,树算法,二叉搜索树,BST操作 (搜索) 在现实世界中的应用场景。
165,BST操作 (搜索) 的理论理解,理论计算机科学,理解BST操作 (搜索) 的原理,不适用,不适用,树算法,二叉搜索树,侧重于BST操作 (搜索) 的理论基础和核心思想。
166,比较：BST操作 (搜索) vs BST操作 (插入),树算法,比较BST操作 (搜索) 和BST操作 (插入) 在二叉搜索树中搜索方面的表现,可变,可变,树算法,二叉搜索树,详细比较BST操作 (搜索) 和BST操作 (插入) 的性能和用例。
167,BST操作 (插入),树算法,插入到二叉搜索树中,O(h),O(h),树算法,二叉搜索树,向二叉搜索树添加一个新节点。
168,BST操作 (插入) (最坏情况),树算法,插入到二叉搜索树中,O(n),O(h),树算法,二叉搜索树,向二叉搜索树添加一个新节点。(最坏情况分析)
169,BST操作 (插入) 的应用,树算法,插入到二叉搜索树中的实际应用,可变,可变,树算法,二叉搜索树,BST操作 (插入) 在现实世界中的应用场景。
170,BST操作 (插入) 的理论理解,理论计算机科学,理解BST操作 (插入) 的原理,不适用,不适用,树算法,二叉搜索树,侧重于BST操作 (插入) 的理论基础和核心思想。
171,比较：BST操作 (插入) vs BST操作 (删除),树算法,比较BST操作 (插入) 和BST操作 (删除) 在插入到二叉搜索树中方面的表现,可变,可变,树算法,二叉搜索树,详细比较BST操作 (插入) 和BST操作 (删除) 的性能和用例。
172,BST操作 (删除),树算法,从二叉搜索树中删除,O(h),O(h),树算法,二叉搜索树,从二叉搜索树中删除一个节点。
173,BST操作 (删除) (最坏情况),树算法,从二叉搜索树中删除,O(n),O(h),树算法,二叉搜索树,从二叉搜索树中删除一个节点。(最坏情况分析)
174,BST操作 (删除) 的应用,树算法,从二叉搜索树中删除的实际应用,可变,可变,树算法,二叉搜索树,BST操作 (删除) 在现实世界中的应用场景。
175,BST操作 (删除) 的理论理解,理论计算机科学,理解BST操作 (删除) 的原理,不适用,不适用,树算法,二叉搜索树,侧重于BST操作 (删除) 的理论基础和核心思想。
176,比较：BST操作 (删除) vs 欧几里得算法,树算法,比较BST操作 (删除) 和欧几里得算法在从二叉搜索树中删除方面的表现,可变,可变,树算法,二叉搜索树,详细比较BST操作 (删除) 和欧几里得算法的性能和用例。
177,欧几里得算法,数论,查找两个数的最大公约数,O(log(min(a,b))),O(1),数论,无,一种计算两个整数的最大公约数 (GCD) 的高效方法。
178,欧几里得算法的应用,数论,查找两个数最大公约数的实际应用,可变,可变,数论,无,欧几里得算法在现实世界中的应用场景。
179,欧几里得算法的理论理解,理论计算机科学,理解欧几里得算法的原理,不适用,不适用,数论,无,侧重于欧几里得算法的理论基础和核心思想。
180,比较：欧几里得算法 vs 埃拉托斯特尼筛法,数论,比较欧几里得算法和埃拉托斯特尼筛法在查找两个数的最大公约数方面的表现,可变,可变,数论,无,详细比较欧几里得算法和埃拉托斯特尼筛法 的性能和用例。
181,埃拉托斯特尼筛法,数论,查找给定限制内的素数,O(n log log n),O(n),数论,数组,一种高效的算法，用于查找给定限制内的所有素数。
182,埃拉托斯特尼筛法的应用,数论,查找给定限制内素数的实际应用,可变,可变,数论,数组,埃拉托斯特尼筛法在现实世界中的应用场景。
183,埃拉托斯特尼筛法的理论理解,理论计算机科学,理解埃拉托斯特尼筛法的原理,不适用,不适用,数论,数组,侧重于埃拉托斯特尼筛法的理论基础和核心思想。
184,比较：埃拉托斯特尼筛法 vs 模幂运算,数论,比较埃拉托斯特尼筛法和模幂运算在查找给定限制内素数方面的表现,可变,可变,数论,数组,详细比较埃拉托斯特尼筛法和模幂运算的性能和用例。
185,模幂运算,数论,计算 (base^exp) % mod,O(log exp),O(1),数论,无,高效计算 (a^b) % m。
186,模幂运算的应用,数论,计算 (base^exp) % mod 的实际应用,可变,可变,数论,无,模幂运算在现实世界中的应用场景。
187,模幂运算的理论理解,理论计算机科学,理解模幂运算的原理,不适用,不适用,数论,无,侧重于模幂运算的理论基础和核心思想。
188,比较：模幂运算 vs A*搜索,数论,比较模幂运算和A*搜索在计算 (base^exp) % mod 方面的表现,可变,可变,数论,无,详细比较模幂运算和A*搜索的性能和用例。
189,A*搜索,路径查找,在图 (启发式) 中查找最短路径,可变,O(V+E),图搜索,优先队列, 图,一种使用启发式函数的知情搜索算法。
190,A*搜索 (最坏情况),路径查找,在图 (启发式) 中查找最短路径,指数级,O(V+E),图搜索,优先队列, 图,一种使用启发式函数的知情搜索算法。(最坏情况分析)
191,A*搜索的应用,路径查找,在图 (启发式) 中查找最短路径的实际应用,可变,可变,图搜索,优先队列, 图,A*搜索在现实世界中的应用场景。
192,A*搜索的理论理解,理论计算机科学,理解A*搜索的原理,不适用,不适用,图搜索,优先队列, 图,侧重于A*搜索的理论基础和核心思想。
193,比较：A*搜索 vs 贪心最佳优先搜索,路径查找,比较A*搜索和贪心最佳优先搜索在在图 (启发式) 中查找最短路径方面的表现,可变,可变,图搜索,优先队列, 图,详细比较A*搜索和贪心最佳优先搜索的性能和用例。
194,贪心最佳优先搜索,路径查找,使用启发式查找路径,可变,O(V),图搜索, 贪心,优先队列, 图,根据启发式函数估计，扩展最接近目标的节点。
195,贪心最佳优先搜索 (最坏情况),路径查找,使用启发式查找路径,指数级,O(V),图搜索, 贪心,优先队列, 图,根据启发式函数估计，扩展最接近目标的节点。(最坏情况分析)
196,贪心最佳优先搜索的应用,路径查找,使用启发式查找路径的实际应用,可变,可变,图搜索, 贪心,优先队列, 图,贪心最佳优先搜索在现实世界中的应用场景。
197,贪心最佳优先搜索的理论理解,理论计算机科学,理解贪心最佳优先搜索的原理,不适用,不适用,图搜索, 贪心,优先队列, 图,侧重于贪心最佳优先搜索的理论基础和核心思想。
198,比较：贪心最佳优先搜索 vs 迭代加深DFS,路径查找,比较贪心最佳优先搜索和迭代加深DFS在使用启发式查找路径方面的表现,可变,可变,图搜索, 贪心,优先队列, 图,详细比较贪心最佳优先搜索和迭代加深DFS的性能和用例。
199,迭代加深DFS,图遍历,查找树/图中的最优路径,O(V+E),O(d),图遍历,栈, 图,结合了DFS的空间效率和BFS的完整性和最优性。
200,迭代加深DFS的应用,图遍历,查找树/图中最优路径的实际应用,可变,可变,图遍历,栈, 图,迭代加深DFS在现实世界中的应用场景。
201,迭代加深DFS的理论理解,理论计算机科学,理解迭代加深DFS的原理,不适用,不适用,图遍历,栈, 图,侧重于迭代加深DFS的理论基础和核心思想。
202,比较：迭代加深DFS vs 双向搜索,图遍历,比较迭代加深DFS和双向搜索在查找树/图中的最优路径方面的表现,可变,可变,图遍历,栈, 图,详细比较迭代加深DFS和双向搜索的性能和用例。
203,双向搜索,图遍历,查找从源到目标的最短路径,O(B^(d/2)),O(B^(d/2)),图遍历,队列, 图,同时运行两个搜索，一个从初始状态向前，一个从目标状态向后。
204,双向搜索的应用,图遍历,查找从源到目标最短路径的实际应用,可变,可变,图遍历,队列, 图,双向搜索在现实世界中的应用场景。
205,双向搜索的理论理解,理论计算机科学,理解双向搜索的原理,不适用,不适用,图遍历,队列, 图,侧重于双向搜索的理论基础和核心思想。
206,比较：双向搜索 vs 最长递增子序列,图遍历,比较双向搜索和最长递增子序列在查找从源到目标的最短路径方面的表现,可变,可变,图遍历,队列, 图,详细比较双向搜索和最长递增子序列的性能和用例。
207,最长递增子序列,动态规划,查找序列中的LIS,O(n log n),O(n),动态规划,数组,找到给定序列的最长子序列，其中子序列的所有元素按递增顺序排序。
208,最长递增子序列的应用,动态规划,查找序列中LIS的实际应用,可变,可变,动态规划,数组,最长递增子序列在现实世界中的应用场景。
209,最长递增子序列的理论理解,理论计算机科学,理解最长递增子序列的原理,不适用,不适用,动态规划,数组,侧重于最长递增子序列的理论基础和核心思想。
210,比较：最长递增子序列 vs 编辑距离 (Levenshtein),动态规划,比较最长递增子序列和编辑距离 (Levenshtein) 在查找序列中LIS方面的表现,可变,可变,动态规划,数组,详细比较最长递增子序列和编辑距离 (Levenshtein) 的性能和用例。
211,编辑距离 (Levenshtein),动态规划,将一个字符串转换为另一个字符串的最小编辑次数,O(mn),O(mn),动态规划,矩阵,计算将一个单词更改为另一个单词所需的最小单字符编辑次数。
212,编辑距离 (Levenshtein) 的应用,动态规划,将一个字符串转换为另一个字符串的最小编辑次数的实际应用,可变,可变,动态规划,矩阵,编辑距离 (Levenshtein) 在现实世界中的应用场景。
213,编辑距离 (Levenshtein) 的理论理解,理论计算机科学,理解编辑距离 (Levenshtein) 的原理,不适用,不适用,动态规划,矩阵,侧重于编辑距离 (Levenshtein) 的理论基础和核心思想。
214,比较：编辑距离 (Levenshtein) vs 硬币找零问题,动态规划,比较编辑距离 (Levenshtein) 和硬币找零问题在将一个字符串转换为另一个字符串的最小编辑次数方面的表现,可变,可变,动态规划,矩阵,详细比较编辑距离 (Levenshtein) 和硬币找零问题 的性能和用例。
215,硬币找零问题,动态规划,查找找零方式或最小硬币数,O(amount * num_coins),O(amount),动态规划,数组,给定一组硬币面额，找到制作给定金额所需的最小硬币数。
216,硬币找零问题的应用,动态规划,查找找零方式或最小硬币数的实际应用,可变,可变,动态规划,数组,硬币找零问题在现实世界中的应用场景。
217,硬币找零问题的理论理解,理论计算机科学,理解硬币找零问题的原理,不适用,不适用,动态规划,数组,侧重于硬币找零问题的理论基础和核心思想。
218,比较：硬币找零问题 vs 最小割最大流,动态规划,比较硬币找零问题和最小割最大流在查找找零方式或最小硬币数方面的表现,可变,可变,动态规划,数组,详细比较硬币找零问题和最小割最大流的性能和用例。
219,最小割最大流,网络流,网络中的最大流,可变,O(V+E),图算法,图,查找流网络中从源到汇的最大可能流。
220,最小割最大流的应用,网络流,网络中最大流的实际应用,可变,可变,图算法,图,最小割最大流在现实世界中的应用场景。
221,最小割最大流的理论理解,理论计算机科学,理解最小割最大流的原理,不适用,不适用,图算法,图,侧重于最小割最大流的理论基础和核心思想。
222,比较：最小割最大流 vs Ford-Fulkerson算法,网络流,比较最小割最大流和Ford-Fulkerson算法在网络中最大流方面的表现,可变,可变,图算法,图,详细比较最小割最大流和Ford-Fulkerson算法的性能和用例。
223,Ford-Fulkerson算法,网络流,网络中的最大流,O(E * max_flow),O(V+E),图算法,图,计算流网络中的最大流。
224,Ford-Fulkerson算法的应用,网络流,网络中最大流的实际应用,可变,可变,图算法,图,Ford-Fulkerson算法在现实世界中的应用场景。
225,Ford-Fulkerson算法的理论理解,理论计算机科学,理解Ford-Fulkerson算法的原理,不适用,不适用,图算法,图,侧重于Ford-Fulkerson算法的理论基础和核心思想。
226,比较：Ford-Fulkerson算法 vs Edmonds-Karp算法,网络流,比较Ford-Fulkerson算法和Edmonds-Karp算法在网络中最大流方面的表现,可变,可变,图算法,图,详细比较Ford-Fulkerson算法和Edmonds-Karp算法的性能和用例。
227,Edmonds-Karp算法,网络流,网络中的最大流,O(VE^2),O(V+E),图算法,图, 队列,Ford-Fulkerson算法的一种实现，使用BFS查找增广路径。
228,Edmonds-Karp算法的应用,网络流,网络中最大流的实际应用,可变,可变,图算法,图, 队列,Edmonds-Karp算法在现实世界中的应用场景。
229,Edmonds-Karp算法的理论理解,理论计算机科学,理解Edmonds-Karp算法的原理,不适用,不适用,图算法,图, 队列,侧重于Edmonds-Karp算法的理论基础和核心思想。
230,比较：Edmonds-Karp算法 vs 凸包 (Jarvis March),网络流,比较Edmonds-Karp算法和凸包 (Jarvis March) 在网络中最大流方面的表现,可变,可变,图算法,图, 队列,详细比较Edmonds-Karp算法和凸包 (Jarvis March) 的性能和用例。
231,凸包 (Jarvis March),计算几何,查找点集的凸包,O(nh),O(h),计算几何,数组, 点集,找到包含给定点集中所有点的最小凸多边形。
232,凸包 (Jarvis March) 的应用,计算几何,查找点集凸包的实际应用,可变,可变,计算几何,数组, 点集,凸包 (Jarvis March) 在现实世界中的应用场景。
233,凸包 (Jarvis March) 的理论理解,理论计算机科学,理解凸包 (Jarvis March) 的原理,不适用,不适用,计算几何,数组, 点集,侧重于凸包 (Jarvis March) 的理论基础和核心思想。
234,比较：凸包 (Jarvis March) vs 凸包 (Graham Scan),计算几何,比较凸包 (Jarvis March) 和凸包 (Graham Scan) 在查找点集凸包方面的表现,可变,可变,计算几何,数组, 点集,详细比较凸包 (Jarvis March) 和凸包 (Graham Scan) 的性能和用例。
235,凸包 (Graham Scan),计算几何,查找点集的凸包,O(n log n),O(n),计算几何,栈, 点集,一种用于查找平面中有限点集凸包的算法。
236,凸包 (Graham Scan) 的应用,计算几何,查找点集凸包的实际应用,可变,可变,计算几何,栈, 点集,凸包 (Graham Scan) 在现实世界中的应用场景。
237,凸包 (Graham Scan) 的理论理解,理论计算机科学,理解凸包 (Graham Scan) 的原理,不适用,不适用,计算几何,栈, 点集,侧重于凸包 (Graham Scan) 的理论基础和核心思想。
238,比较：凸包 (Graham Scan) vs Splay Tree操作,计算几何,比较凸包 (Graham Scan) 和Splay Tree操作在查找点集凸包方面的表现,可变,可变,计算几何,栈, 点集,详细比较凸包 (Graham Scan) 和Splay Tree操作的性能和用例。
239,Splay Tree操作,自平衡树,动态集操作 (搜索、插入、删除),O(log n) 摊还,O(n),树算法,伸展树,一种自平衡二叉搜索树，将频繁访问的节点移动到根。
240,Splay Tree操作 (最坏情况),自平衡树,动态集操作 (搜索、插入、删除),O(n),O(n),树算法,伸展树,一种自平衡二叉搜索树，将频繁访问的节点移动到根。(最坏情况分析)
241,Splay Tree操作的应用,自平衡树,动态集操作 (搜索、插入、删除) 的实际应用,可变,可变,树算法,伸展树,Splay Tree操作在现实世界中的应用场景。
242,Splay Tree操作的理论理解,理论计算机科学,理解Splay Tree操作的原理,不适用,不适用,树算法,伸展树,侧重于Splay Tree操作的理论基础和核心思想。
243,比较：Splay Tree操作 vs AVL Tree操作,自平衡树,比较Splay Tree操作和AVL Tree操作在动态集操作 (搜索、插入、删除) 方面的表现,可变,可变,树算法,伸展树,详细比较Splay Tree操作和AVL Tree操作的性能和用例。
244,AVL Tree操作,自平衡树,动态集操作 (搜索、插入、删除),O(log n),O(n),树算法,AVL树,一种自平衡二叉搜索树，其中任何节点的两个子树的高度差最多为一。
245,AVL Tree操作的应用,自平衡树,动态集操作 (搜索、插入、删除) 的实际应用,可变,可变,树算法,AVL树,AVL Tree操作在现实世界中的应用场景。
246,AVL Tree操作的理论理解,理论计算机科学,理解AVL Tree操作的原理,不适用,不适用,树算法,AVL树,侧重于AVL Tree操作的理论基础和核心思想。
247,比较：AVL Tree操作 vs Red-Black Tree操作,自平衡树,比较AVL Tree操作和Red-Black Tree操作在动态集操作 (搜索、插入、删除) 方面的表现,可变,可变,树算法,AVL树,详细比较AVL Tree操作和Red-Black Tree操作的性能和用例。
248,Red-Black Tree操作,自平衡树,动态集操作 (搜索、插入、删除),O(log n),O(n),树算法,红黑树,一种自平衡二叉搜索树，使用颜色属性来确保平衡。
249,Red-Black Tree操作的应用,自平衡树,动态集操作 (搜索、插入、删除) 的实际应用,可变,可变,树算法,红黑树,Red-Black Tree操作在现实世界中的应用场景。
250,Red-Black Tree操作的理论理解,理论计算机科学,理解Red-Black Tree操作的原理,不适用,不适用,树算法,红黑树,侧重于Red-Black Tree操作的理论基础和核心思想。
251,比较：Red-Black Tree操作 vs Trie操作,自平衡树,比较Red-Black Tree操作和Trie操作在动态集操作 (搜索、插入、删除) 方面的表现,可变,可变,树算法,红黑树,详细比较Red-Black Tree操作和Trie操作的性能和用例。
252,Trie操作,字符串数据结构,高效字符串检索,O(L),O(N*L),字符串算法,前缀树,一种树状数据结构，用于存储动态字符串集。
253,Trie操作的应用,字符串数据结构,高效字符串检索的实际应用,可变,可变,字符串算法,前缀树,Trie操作在现实世界中的应用场景。
254,Trie操作的理论理解,理论计算机科学,理解Trie操作的原理,不适用,不适用,字符串算法,前缀树,侧重于Trie操作的理论基础和核心思想。
255,比较：Trie操作 vs 后缀数组构建,字符串数据结构,比较Trie操作和后缀数组构建在高效字符串检索方面的表现,可变,可变,字符串算法,前缀树,详细比较Trie操作和后缀数组构建的性能和用例。
256,后缀数组构建,字符串算法,字符串搜索、模式匹配,O(n log n),O(n),字符串算法,数组,给定字符串的所有后缀的排序数组。
257,后缀数组构建的应用,字符串算法,字符串搜索、模式匹配的实际应用,可变,可变,字符串算法,数组,后缀数组构建在现实世界中的应用场景。
258,后缀数组构建的理论理解,理论计算机科学,理解后缀数组构建的原理,不适用,不适用,字符串算法,数组,侧重于后缀数组构建的理论基础和核心思想。
259,比较：后缀数组构建 vs 后缀树构建,字符串算法,比较后缀数组构建和后缀树构建在字符串搜索、模式匹配方面的表现,可变,可变,字符串算法,数组,详细比较后缀数组构建和后缀树构建的性能和用例。
260,后缀树构建,字符串算法,字符串搜索、模式匹配,O(n),O(n),字符串算法,树,给定字符串的所有后缀的压缩前缀树。
261,后缀树构建的应用,字符串算法,字符串搜索、模式匹配的实际应用,可变,可变,字符串算法,树,后缀树构建在现实世界中的应用场景。
262,后缀树构建的理论理解,理论计算机科学,理解后缀树构建的原理,不适用,不适用,字符串算法,树,侧重于后缀树构建的理论基础和核心思想。
263,比较：后缀树构建 vs 并查集,字符串算法,比较后缀树构建和并查集在字符串搜索、模式匹配方面的表现,可变,可变,字符串算法,树,详细比较后缀树构建和并查集的性能和用例。
264,并查集,不相交集,管理不相交集,O(alpha(n)) 摊还,O(n),数据结构,数组,一种存储不相交集集合的数据结构。
265,并查集的应用,不相交集,管理不相交集的实际应用,可变,可变,数据结构,数组,并查集在现实世界中的应用场景。
266,并查集的理论理解,理论计算机科学,理解并查集的原理,不适用,不适用,数据结构,数组,侧重于并查集的理论基础和核心思想。
267,比较：并查集 vs Fenwick树 (BIT),不相交集,比较并查集和Fenwick树 (BIT) 在管理不相交集方面的表现,可变,可变,数据结构,数组,详细比较并查集和Fenwick树 (BIT) 的性能和用例。
268,Fenwick树 (BIT),数据结构,前缀和查询、范围更新,O(log n),O(n),数据结构,数组,一种可以有效地更新元素和计算数字表中前缀和的数据结构。
269,Fenwick树 (BIT) 的应用,数据结构,前缀和查询、范围更新的实际应用,可变,可变,数据结构,数组,Fenwick树 (BIT) 在现实世界中的应用场景。
270,Fenwick树 (BIT) 的理论理解,理论计算机科学,理解Fenwick树 (BIT) 的原理,不适用,不适用,数据结构,数组,侧重于Fenwick树 (BIT) 的理论基础和核心思想。
271,比较：Fenwick树 (BIT) vs 线段树,数据结构,比较Fenwick树 (BIT) 和线段树在前缀和查询、范围更新方面的表现,可变,可变,数据结构,数组,详细比较Fenwick树 (BIT) 和线段树的性能和用例。
272,线段树,数据结构,范围查询 (求和、最小值、最大值)、范围更新,O(log n),O(n),数据结构,树, 数组,一种树形数据结构，用于存储关于区间或段的信息。
273,线段树的应用,数据结构,范围查询 (求和、最小值、最大值)、范围更新的实际应用,可变,可变,数据结构,树, 数组,线段树在现实世界中的应用场景。
274,线段树的理论理解,理论计算机科学,理解线段树的原理,不适用,不适用,数据结构,树, 数组,侧重于线段树的理论基础和核心思想。
275,比较：线段树 vs 最小生成树 (通用),数据结构,比较线段树和最小生成树 (通用) 在范围查询 (求和、最小值、最大值)、范围更新方面的表现,可变,可变,数据结构,树, 数组,详细比较线段树和最小生成树 (通用) 的性能和用例。
276,最小生成树 (通用),图算法,以最小总边权重连接所有顶点,可变,可变,贪心,图,连通的、带边权重的无向图的边子集，它连接所有顶点，没有循环，并且总边权重最小。
277,最小生成树 (通用) 的应用,图算法,以最小总边权重连接所有顶点的实际应用,可变,可变,贪心,图,最小生成树 (通用) 在现实世界中的应用场景。
278,最小生成树 (通用) 的理论理解,理论计算机科学,理解最小生成树 (通用) 的原理,不适用,不适用,贪心,图,侧重于最小生成树 (通用) 的理论基础和核心思想。
279,比较：最小生成树 (通用) vs 最短路径 (通用),图算法,比较最小生成树 (通用) 和最短路径 (通用) 在以最小总边权重连接所有顶点方面的表现,可变,可变,贪心,图,详细比较最小生成树 (通用) 和最短路径 (通用) 的性能和用例。
280,最短路径 (通用),图算法,查找两个顶点之间的最短路径,可变,可变,图算法,图,查找图中两个顶点之间的路径，使得其组成边的权重之和最小。
281,最短路径 (通用) 的应用,图算法,查找两个顶点之间最短路径的实际应用,可变,可变,图算法,图,最短路径 (通用) 在现实世界中的应用场景。
282,最短路径 (通用) 的理论理解,理论计算机科学,理解最短路径 (通用) 的原理,不适用,不适用,图算法,图,侧重于最短路径 (通用) 的理论基础和核心思想。
283,比较：最短路径 (通用) vs 网络流 (通用),图算法,比较最短路径 (通用) 和网络流 (通用) 在查找两个顶点之间最短路径方面的表现,可变,可变,图算法,图,详细比较最短路径 (通用) 和网络流 (通用) 的性能和用例。
284,网络流 (通用),网络流,最大化通过网络的流量,可变,可变,图算法,图,处理将某种商品从源点流到汇点在网络中最大化流量的问题。
285,网络流 (通用) 的应用,网络流,最大化通过网络流量的实际应用,可变,可变,图算法,图,网络流 (通用) 在现实世界中的应用场景。
286,网络流 (通用) 的理论理解,理论计算机科学,理解网络流 (通用) 的原理,不适用,不适用,图算法,图,侧重于网络流 (通用) 的理论基础和核心思想。
287,比较：网络流 (通用) vs 字符串匹配 (通用),网络流,比较网络流 (通用) 和字符串匹配 (通用) 在最大化通过网络的流量方面的表现,可变,可变,图算法,图,详细比较网络流 (通用) 和字符串匹配 (通用) 的性能和用例。
288,字符串匹配 (通用),字符串算法,查找文本中模式的出现,可变,可变,字符串算法,字符串,在文本字符串中查找模式字符串的所有出现的问题。
289,字符串匹配 (通用) 的应用,字符串算法,查找文本中模式出现的实际应用,可变,可变,字符串算法,字符串,字符串匹配 (通用) 在现实世界中的应用场景。
290,字符串匹配 (通用) 的理论理解,理论计算机科学,理解字符串匹配 (通用) 的原理,不适用,不适用,字符串算法,字符串,侧重于字符串匹配 (通用) 的理论基础和核心思想。
291,比较：字符串匹配 (通用) vs 计算几何 (通用),字符串算法,比较字符串匹配 (通用) 和计算几何 (通用) 在查找文本中模式的出现方面的表现,可变,可变,字符串算法,字符串,详细比较字符串匹配 (通用) 和计算几何 (通用) 的性能和用例。
292,计算几何 (通用),计算几何,处理几何对象的算法,可变,可变,几何算法,点集, 线段,与几何问题相关的算法。
293,计算几何 (通用) 的应用,计算几何,处理几何对象算法的实际应用,可变,可变,几何算法,点集, 线段,计算几何 (通用) 在现实世界中的应用场景。
294,计算几何 (通用) 的理论理解,理论计算机科学,理解计算几何 (通用) 的原理,不适用,不适用,几何算法,点集, 线段,侧重于计算几何 (通用) 的理论基础和核心思想。
295,比较：计算几何 (通用) vs 随机化算法 (通用),计算几何,比较计算几何 (通用) 和随机化算法 (通用) 在处理几何对象算法方面的表现,可变,可变,几何算法,点集, 线段,详细比较计算几何 (通用) 和随机化算法 (通用) 的性能和用例。
296,随机化算法 (通用),算法设计,使用随机性解决问题,可变,可变,随机化算法,无,在执行过程中做出随机选择的算法。
297,随机化算法 (通用) 的应用,算法设计,使用随机性解决问题的实际应用,可变,可变,随机化算法,无,随机化算法 (通用) 在现实世界中的应用场景。
298,随机化算法 (通用) 的理论理解,理论计算机科学,理解随机化算法 (通用) 的原理,不适用,不适用,随机化算法,无,侧重于随机化算法 (通用) 的理论基础和核心思想。
299,比较：随机化算法 (通用) vs 近似算法 (通用),算法设计,比较随机化算法 (通用) 和近似算法 (通用) 在使用随机性解决问题方面的表现,可变,可变,随机化算法,无,详细比较随机化算法 (通用) 和近似算法 (通用) 的性能和用例。
300,近似算法 (通用),算法设计,为NP-hard问题查找近似最优解,可变,可变,近似算法,无,查找优化问题的近似解的算法。
301,近似算法 (通用) 的应用,算法设计,为NP-hard问题查找近似最优解的实际应用,可变,可变,近似算法,无,近似算法 (通用) 在现实世界中的应用场景。
302,近似算法 (通用) 的理论理解,理论计算机科学,理解近似算法 (通用) 的原理,不适用,不适用,近似算法,无,侧重于近似算法 (通用) 的理论基础和核心思想。
303,比较：近似算法 (通用) vs 在线算法 (通用),算法设计,比较近似算法 (通用) 和在线算法 (通用) 在为NP-hard问题查找近似最优解方面的表现,可变,可变,近似算法,无,详细比较近似算法 (通用) 和在线算法 (通用) 的性能和用例。
304,在线算法 (通用),算法设计,逐段处理输入而不知道未来的情况,可变,可变,在线算法,无,逐段串行处理输入的算法。
305,在线算法 (通用) 的应用,算法设计,逐段处理输入而不知道未来的情况的实际应用,可变,可变,在线算法,无,在线算法 (通用) 在现实世界中的应用场景。
306,在线算法 (通用) 的理论理解,理论计算机科学,理解在线算法 (通用) 的原理,不适用,不适用,在线算法,无,侧重于在线算法 (通用) 的理论基础和核心思想。
307,比较：在线算法 (通用) vs 离线算法 (通用),算法设计,比较在线算法 (通用) 和离线算法 (通用) 在逐段处理输入而不知道未来的情况方面的表现,可变,可变,在线算法,无,详细比较在线算法 (通用) 和离线算法 (通用) 的性能和用例。
308,离线算法 (通用),算法设计,在完全接收输入后才处理输入,可变,可变,离线算法,无,需要先知道完整输入才能处理的算法。
309,离线算法 (通用) 的应用,算法设计,在完全接收输入后才处理输入的实际应用,可变,可变,离线算法,无,离线算法 (通用) 在现实世界中的应用场景。
310,离线算法 (通用) 的理论理解,理论计算机科学,理解离线算法 (通用) 的原理,不适用,不适用,离线算法,无,侧重于离线算法 (通用) 的理论基础和核心思想。
311,比较：离线算法 (通用) vs 并行算法 (通用),算法设计,比较离线算法 (通用) 和并行算法 (通用) 在在完全接收输入后才处理输入方面的表现,可变,可变,离线算法,无,详细比较离线算法 (通用) 和并行算法 (通用) 的性能和用例。
312,并行算法 (通用),算法设计,同时使用多个处理器解决问题,可变,可变,并行计算,无,旨在同时在多个处理器上工作的算法。
313,并行算法 (通用) 的应用,算法设计,同时使用多个处理器解决问题的实际应用,可变,可变,并行计算,无,并行算法 (通用) 在现实世界中的应用场景。
314,并行算法 (通用) 的理论理解,理论计算机科学,理解并行算法 (通用) 的原理,不适用,不适用,并行计算,无,侧重于并行算法 (通用) 的理论基础和核心思想。
315,比较：并行算法 (通用) vs 分布式算法 (通用),算法设计,比较并行算法 (通用) 和分布式算法 (通用) 在同时使用多个处理器解决问题方面的表现,可变,可变,并行计算,无,详细比较并行算法 (通用) 和分布式算法 (通用) 的性能和用例。
316,分布式算法 (通用),算法设计,跨多个互连计算机解决问题,可变,可变,分布式计算,无,旨在在独立处理器网络上运行的算法。
317,分布式算法 (通用) 的应用,算法设计,跨多个互连计算机解决问题的实际应用,可变,可变,分布式计算,无,分布式算法 (通用) 在现实世界中的应用场景。
318,分布式算法 (通用) 的理论理解,理论计算机科学,理解分布式算法 (通用) 的原理,不适用,不适用,分布式计算,无,侧重于分布式算法 (通用) 的理论基础和核心思想。
319,比较：分布式算法 (通用) vs 机器学习算法 (通用),算法设计,比较分布式算法 (通用) 和机器学习算法 (通用) 在跨多个互连计算机解决问题方面的表现,可变,可变,分布式计算,无,详细比较分布式算法 (通用) 和机器学习算法 (通用) 的性能和用例。
320,机器学习算法 (通用),机器学习,从数据中学习,可变,可变,机器学习,数据集,使系统能够从数据中学习而无需明确编程的算法。
321,机器学习算法 (通用) 的应用,机器学习,从数据中学习的实际应用,可变,可变,机器学习,数据集,机器学习算法 (通用) 在现实世界中的应用场景。
322,机器学习算法 (通用) 的理论理解,理论计算机科学,理解机器学习算法 (通用) 的原理,不适用,不适用,机器学习,数据集,侧重于机器学习算法 (通用) 的理论基础和核心思想。
323,比较：机器学习算法 (通用) vs 聚类算法 (通用),机器学习,比较机器学习算法 (通用) 和聚类算法 (通用) 在从数据中学习方面的表现,可变,可变,机器学习,数据集,详细比较机器学习算法 (通用) 和聚类算法 (通用) 的性能和用例。
324,聚类算法 (通用),机器学习,分组数据点,可变,可变,无监督学习,数据集,将一组对象分组，使得同一组 (簇) 中的对象彼此之间比与其他组中的对象更相似。
325,聚类算法 (通用) 的应用,机器学习,分组数据点的实际应用,可变,可变,无监督学习,数据集,聚类算法 (通用) 在现实世界中的应用场景。
326,聚类算法 (通用) 的理论理解,理论计算机科学,理解聚类算法 (通用) 的原理,不适用,不适用,无监督学习,数据集,侧重于聚类算法 (通用) 的理论基础和核心思想。
327,比较：聚类算法 (通用) vs 分类算法 (通用),机器学习,比较聚类算法 (通用) 和分类算法 (通用) 在分组数据点方面的表现,可变,可变,无监督学习,数据集,详细比较聚类算法 (通用) 和分类算法 (通用) 的性能和用例。
328,分类算法 (通用),机器学习,对数据点进行分类,可变,可变,监督学习,数据集,将类别分配给数据点的算法。
329,分类算法 (通用) 的应用,机器学习,对数据点进行分类的实际应用,可变,可变,监督学习,数据集,分类算法 (通用) 在现实世界中的应用场景。
330,分类算法 (通用) 的理论理解,理论计算机科学,理解分类算法 (通用) 的原理,不适用,不适用,监督学习,数据集,侧重于分类算法 (通用) 的理论基础和核心思想。
331,比较：分类算法 (通用) vs 回归算法 (通用),机器学习,比较分类算法 (通用) 和回归算法 (通用) 在对数据点进行分类方面的表现,可变,可变,监督学习,数据集,详细比较分类算法 (通用) 和回归算法 (通用) 的性能和用例。
332,回归算法 (通用),机器学习,预测连续值,可变,可变,监督学习,数据集,预测连续输出变量的算法。
333,回归算法 (通用) 的应用,机器学习,预测连续值的实际应用,可变,可变,监督学习,数据集,回归算法 (通用) 在现实世界中的应用场景。
334,回归算法 (通用) 的理论理解,理论计算机科学,理解回归算法 (通用) 的原理,不适用,不适用,监督学习,数据集,侧重于回归算法 (通用) 的理论基础和核心思想。
335,比较：回归算法 (通用) vs 强化学习算法 (通用),机器学习,比较回归算法 (通用) 和强化学习算法 (通用) 在预测连续值方面的表现,可变,可变,监督学习,数据集,详细比较回归算法 (通用) 和强化学习算法 (通用) 的性能和用例。
336,强化学习算法 (通用),机器学习,通过试错学习最优行动,可变,可变,强化学习,环境,代理通过在环境中执行操作来学习决策以最大化累积奖励的算法。
337,强化学习算法 (通用) 的应用,机器学习,通过试错学习最优行动的实际应用,可变,可变,强化学习,环境,强化学习算法 (通用) 在现实世界中的应用场景。
338,强化学习算法 (通用) 的理论理解,理论计算机科学,理解强化学习算法 (通用) 的原理,不适用,不适用,强化学习,环境,侧重于强化学习算法 (通用) 的理论基础和核心思想。
339,比较：强化学习算法 (通用) vs 遗传算法,机器学习,比较强化学习算法 (通用) 和遗传算法在通过试错学习最优行动方面的表现,可变,可变,强化学习,环境,详细比较强化学习算法 (通用) 和遗传算法的性能和用例。
340,遗传算法,优化,解决优化和搜索问题,可变,可变,进化计算,种群,一种受自然选择过程启发的元启发式算法。
341,遗传算法的应用,优化,解决优化和搜索问题的实际应用,可变,可变,进化计算,种群,遗传算法在现实世界中的应用场景。
342,遗传算法的理论理解,理论计算机科学,理解遗传算法的原理,不适用,不适用,进化计算,种群,侧重于遗传算法的理论基础和核心思想。
343,比较：遗传算法 vs 模拟退火,优化,比较遗传算法和模拟退火在解决优化和搜索问题方面的表现,可变,可变,进化计算,种群,详细比较遗传算法和模拟退火的性能和用例。
344,模拟退火,优化,在大搜索空间中查找全局最优解,可变,O(1),元启发式,无,一种近似给定函数的全局最优解的概率技术。
345,模拟退火的应用,优化,在大搜索空间中查找全局最优解的实际应用,可变,可变,元启发式,无,模拟退火在现实世界中的应用场景。
346,模拟退火的理论理解,理论计算机科学,理解模拟退火的原理,不适用,不适用,元启发式,无,侧重于模拟退火的理论基础和核心思想。
347,比较：模拟退火 vs 蚁群优化,优化,比较模拟退火和蚁群优化在在大搜索空间中查找全局最优解方面的表现,可变,可变,元启发式,无,详细比较模拟退火和蚁群优化的性能和用例。
348,蚁群优化,优化,解决组合优化问题,可变,可变,群智能,图,一种用于解决可以简化为在图中找到良好路径的计算问题的概率技术。
349,蚁群优化的应用,优化,解决组合优化问题的实际应用,可变,可变,群智能,图,蚁群优化在现实世界中的应用场景。
350,蚁群优化的理论理解,理论计算机科学,理解蚁群优化的原理,不适用,不适用,群智能,图,侧重于蚁群优化的理论基础和核心思想。
351,比较：蚁群优化 vs 粒子群优化,优化,比较蚁群优化和粒子群优化在解决组合优化问题方面的表现,可变,可变,群智能,图,详细比较蚁群优化和粒子群优化的性能和用例。
352,粒子群优化,优化,解决优化问题,可变,可变,群智能,种群,一种通过迭代尝试改进候选解决方案以获得给定质量度量来优化问题的计算方法。
353,粒子群优化的应用,优化,解决优化问题的实际应用,可变,可变,群智能,种群,粒子群优化在现实世界中的应用场景。
354,粒子群优化的理论理解,理论计算机科学,理解粒子群优化的原理,不适用,不适用,群智能,种群,侧重于粒子群优化的理论基础和核心思想。
355,比较：粒子群优化 vs 贪心算法 (通用),优化,比较粒子群优化和贪心算法 (通用) 在解决优化问题方面的表现,可变,可变,群智能,种群,详细比较粒子群优化和贪心算法 (通用) 的性能和用例。
356,贪心算法 (通用),算法设计,做出局部最优选择以找到全局最优解,可变,可变,贪心,无,一种遵循问题解决启发式的算法范式，即在每个阶段做出局部最优选择。
357,贪心算法 (通用) 的应用,算法设计,做出局部最优选择以找到全局最优解的实际应用,可变,可变,贪心,无,贪心算法 (通用) 在现实世界中的应用场景。
358,贪心算法 (通用) 的理论理解,理论计算机科学,理解贪心算法 (通用) 的原理,不适用,不适用,贪心,无,侧重于贪心算法 (通用) 的理论基础和核心思想。
359,比较：贪心算法 (通用) vs 分治 (通用),算法设计,比较贪心算法 (通用) 和分治 (通用) 在做出局部最优选择以找到全局最优解方面的表现,可变,可变,贪心,无,详细比较贪心算法 (通用) 和分治 (通用) 的性能和用例。
360,分治 (通用),算法设计,将问题分解为子问题,可变,可变,分治,无,一种基于多分支递归的算法设计范式。
361,分治 (通用) 的应用,算法设计,将问题分解为子问题的实际应用,可变,可变,分治,无,分治 (通用) 在现实世界中的应用场景。
362,分治 (通用) 的理论理解,理论计算机科学,理解分治 (通用) 的原理,不适用,不适用,分治,无,侧重于分治 (通用) 的理论基础和核心思想。
363,比较：分治 (通用) vs 动态规划 (通用),算法设计,比较分治 (通用) 和动态规划 (通用) 在将问题分解为子问题方面的表现,可变,可变,分治,无,详细比较分治 (通用) 和动态规划 (通用) 的性能和用例。
364,动态规划 (通用),算法设计,通过将复杂问题分解为更简单的子问题来解决,可变,可变,动态规划,表格,一种通过将复杂问题分解为更简单的子问题来解决的方法。
365,动态规划 (通用) 的应用,算法设计,通过将复杂问题分解为更简单的子问题来解决的实际应用,可变,可变,动态规划,表格,动态规划 (通用) 在现实世界中的应用场景。
366,动态规划 (通用) 的理论理解,理论计算机科学,理解动态规划 (通用) 的原理,不适用,不适用,动态规划,表格,侧重于动态规划 (通用) 的理论基础和核心思想。
367,比较：动态规划 (通用) vs 回溯 (通用),算法设计,比较动态规划 (通用) 和回溯 (通用) 在通过将复杂问题分解为更简单的子问题来解决方面的表现,可变,可变,动态规划,表格,详细比较动态规划 (通用) 和回溯 (通用) 的性能和用例。
368,回溯 (通用),算法设计,查找计算问题的所有 (或部分) 解决方案,可变,可变,回溯,栈,一种用于查找某些计算问题 (特别是约束满足问题) 的所有 (或部分) 解决方案的通用算法，它逐步构建解决方案的候选者。
369,回溯 (通用) 的应用,算法设计,查找计算问题的所有 (或部分) 解决方案的实际应用,可变,可变,回溯,栈,回溯 (通用) 在现实世界中的应用场景。
370,回溯 (通用) 的理论理解,理论计算机科学,理解回溯 (通用) 的原理,不适用,不适用,回溯,栈,侧重于回溯 (通用) 的理论基础和核心思想。
371,比较：回溯 (通用) vs 暴力 (通用),算法设计,比较回溯 (通用) 和暴力 (通用) 在查找计算问题的所有 (或部分) 解决方案方面的表现,可变,可变,回溯,栈,详细比较回溯 (通用) 和暴力 (通用) 的性能和用例。
372,暴力 (通用),算法设计,尝试所有可能性,可变,可变,暴力,无,一种解决问题的直接方法，通常直接基于问题陈述和定义。
373,暴力 (通用) 的应用,算法设计,尝试所有可能性的实际应用,可变,可变,暴力,无,暴力 (通用) 在现实世界中的应用场景。
374,暴力 (通用) 的理论理解,理论计算机科学,理解暴力 (通用) 的原理,不适用,不适用,暴力,无,侧重于暴力 (通用) 的理论基础和核心思想。
375,比较：暴力 (通用) vs 递归 (通用),算法设计,比较暴力 (通用) 和递归 (通用) 在尝试所有可能性方面的表现,可变,可变,暴力,无,详细比较暴力 (通用) 和递归 (通用) 的性能和用例。
376,递归 (通用),算法设计,通过调用自身解决问题,可变,可变,递归,调用栈,一种解决方案依赖于相同问题的较小实例的解决方案的方法。
377,递归 (通用) 的应用,算法设计,通过调用自身解决问题的实际应用,可变,可变,递归,调用栈,递归 (通用) 在现实世界中的应用场景。
378,递归 (通用) 的理论理解,理论计算机科学,理解递归 (通用) 的原理,不适用,不适用,递归,调用栈,侧重于递归 (通用) 的理论基础和核心思想。
379,比较：递归 (通用) vs 冒泡排序,算法设计,比较递归 (通用) 和冒泡排序在通过调用自身解决问题方面的表现,可变,可变,递归,调用栈,详细比较递归 (通用) 和冒泡排序的性能和用例。
